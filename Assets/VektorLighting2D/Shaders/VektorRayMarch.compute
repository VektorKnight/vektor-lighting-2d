#pragma kernel InitializeRays;
#pragma kernel MarchRays;
#pragma kernel GenerateResult;

#include "RayMarchCommon.cginc"

// General config.
uint MaxSteps;
uint MaxBounces;
uint LightCount;

uint Width;
uint Height;

// Light buffers.
StructuredBuffer<PointLight> PointLights;

// Occluder buffers.
StructuredBuffer<Circle> Circles;
StructuredBuffer<Rect> Rects;

// Rays and result.
ConsumeStructuredBuffer<Ray> InputRays;
AppendStructuredBuffer<Ray> OutputRays;

RWStructuredBuffer<uint> Accumulation;
RWTexture2D<float4> Result;

float SceneDistance(const float2 position) {
    float d = 1e8;

    // Test against all circles.
    uint nc, cs;
    Circles.GetDimensions(nc, cs);
    for (uint j = 0; j < nc; j++) {
        const Circle circle = Circles[j];
        const float cd = CircleSDF(circle, position);
        d = min(cd, d);
    }

    // Test against all rects.
    uint rc, rs;
    Rects.GetDimensions(rc, rs);
    for (uint i = 0; i < rc; i++) {
        const Rect rect = Rects[i];
        const float cd = RectSDF(rect, position);
        d = min(cd, d);
    }
    
    return d;
}

// Generates rays for all light sources for which the position is within the influence of.
void GenerateLightRays(const float2 position, const uint id) {
    for (uint i = 0; i < LightCount; i++) {
        const PointLight light = PointLights[i];
        
        const float light_dist = distance(position, light.position);
        const float scene_dist = SceneDistance(position);
        
        // Skip if ray origin is outside the light's influence.
        if (light_dist > light.radius || scene_dist < 1e-4) {
            continue;
        }
        
        const float falloff = 1.0 - clamp(light_dist / light.radius, 0, 1);
        
        Ray ray;
        ray.id = id;
        ray.color = light.color * (falloff * falloff);
        ray.origin = position;
        ray.direction = normalize(light.position - position);
        ray.distance = 0.0;
        
        ray.light_id = i;
        ray.light_distance = light_dist;

        OutputRays.Append(ray);
    }
}

void AddRayContribution(const Ray ray, const float scale) {
    // Build packed RGBA value.
    // Alpha is ignored since it just gets hard-set later.
    const float3 color = ray.color * scale;
    const uint3 v = uint3 (
        (uint)(color.r * 255) & 0xFF,
        (uint)(color.g * 255) & 0xFF,
        (uint)(color.b * 255) & 0xFF
    );
    
    uint current = 0;
    uint original = 0;
    while (true) {
        const uint updated = AddPacked(current, v);
        InterlockedCompareExchange(Accumulation[ray.id], current, updated, original);
        if (original == current) {
            break;
        }

        current = original;
    }
}

// Generates rays for each pixel.
[numthreads(8,8,1)]
void InitializeRays (uint3 id : SV_DispatchThreadID) {
    GenerateLightRays(id.xy, id.x + id.y * Width);

    Accumulation[id.x + id.y * Width] = 0;
    Result[id.xy] = float4(0,0,0,0);
}

// Marches each ray once and adds their contribution to the accumulation buffer.
// Rays which hit something other than their target light will generate bounce rays if enabled.
[numthreads(64, 1, 1)]
void MarchRays (uint3 id : SV_DispatchThreadID) {
    Ray ray = InputRays.Consume();
    
    if (ray.light_distance == 0) {
        return;
    }
    
    float light_contribution = 1.0;
    for (uint i = 0; i < MaxSteps; i++) {
        // Hit the light.
        if (ray.distance > ray.light_distance) {
            AddRayContribution(ray, clamp(light_contribution, 1e-1, 1));
            break;
        }

        // Hit something else.
        const float2 rayPos = ray.origin + ray.direction * ray.distance;
        const float scene_distance = SceneDistance(rayPos);
        if (scene_distance < 1e-1) {
            break;
        }

        light_contribution = min(light_contribution, scene_distance / 3);

        // Keep going.
        ray.distance += scene_distance;
    }
}

// Generates the final output texture from the accumulation buffer.
[numthreads(8, 8, 1)]
void GenerateResult(uint3 id : SV_DispatchThreadID) {
    const uint packed = Accumulation[id.x + id.y * Width];

    const float4 final = float4(
        (float)(packed & 0xFF) / 255.0,
        (float)(packed >> 8 & 0xFF) / 255.0,
        (float)(packed >> 16 & 0xFF) / 255.0,
        1.0
    );

    Result[id.xy] = final;
}
